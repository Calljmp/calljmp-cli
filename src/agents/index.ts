import chalk from 'chalk';
import ora from 'ora';
import fs from 'fs/promises';
import {
  jsonToAgent,
  Project,
  ServiceError,
  ServiceErrorCode,
} from '../common';
import { Config } from '../config';
import TemplateGitIgnore from './templates/git-ignore.mst';
import TemplateIndex from './templates/index.mst';
import TemplatePackage from './templates/package.mst';
import TemplateTsConfig from './templates/tsconfig.mst';
import mustache from 'mustache';
import logger from '../logger';
import { toKebabCase, toSentenceCase } from '../utils/case';
import path from 'path';
import fetch from 'node-fetch';
import esbuild from 'esbuild';
import { Vault } from '../vault';

export class Agents {
  constructor(private _config: Config) {}

  async initializeProject(project: Project) {
    const spinner = ora(chalk.blue('Generating project...')).start();

    try {
      const projectDir = this._config.projectDirectory;
      await fs.mkdir(projectDir, { recursive: true });

      const filesToCreate = [
        { name: '.gitignore', content: TemplateGitIgnore },
        {
          name: 'index.ts',
          content: mustache.render(TemplateIndex, {
            agentName: toSentenceCase(project.name),
            agentDescription:
              project.description ||
              `${toSentenceCase(project.name)} agent powered by Calljmp.`,
          }),
        },
        {
          name: 'package.json',
          content: mustache.render(TemplatePackage, {
            packageName: toKebabCase(project.name),
          }),
        },
        { name: 'tsconfig.json', content: TemplateTsConfig },
      ];

      const skipped = [];

      for (const file of filesToCreate) {
        const filePath = path.join(projectDir, file.name);

        const fileStat = await fs.stat(filePath).catch(() => null);
        if (fileStat) {
          skipped.push(file.name);
          continue;
        }

        await fs.writeFile(filePath, file.content);
      }

      if (skipped.length > 0) {
        spinner.warn(
          chalk.yellow(
            `Project generated with some existing files skipped: ${skipped.join(', ')}`
          )
        );
      } else {
        spinner.succeed(chalk.green('Project generated successfully.'));
      }

      console.log(chalk.blue('\nNext steps:'));
      console.log(chalk.blue('1. Install dependencies:'));
      console.log(
        chalk.cyan(`   cd ${path.relative(process.cwd(), projectDir)}`)
      );
      console.log(chalk.cyan('   npm install'));
      console.log(chalk.blue('2. Implement your agent logic in index.ts'));
      console.log(chalk.blue('3. Deploy your agent using the CLI\n'));
    } catch (error) {
      spinner.fail(chalk.red('Failed to generate project.'));
      logger.error(chalk.red(`Error: ${(error as Error).message}`));
    }
  }

  async generateTypes(project: Project) {
    const spinner = ora(chalk.blue('Generating types...')).start();
    try {
      const vault = new Vault(this._config);
      const keyValues = await vault.list(project);
      const keyValuesEntries = keyValues
        .map(
          kv =>
            `    ${kv.keyName}: ${kv.isSensitive ? kv.metadata?.type || 'unknown' : JSON.stringify(kv.value)};`
        )
        .join('\n');

      await fs.mkdir(this._config.typesDirectory, { recursive: true });

      const typesContent = `
      // Do not edit this file directly. It is generated by the Calljmp CLI.

/* eslint-disable */

export * from '@calljmp/agent';

declare module '@calljmp/agent' {
  interface KeyValues {
${keyValuesEntries}
  }
}
`;

      const typesPath = path.join(this._config.typesDirectory, 'agent.d.ts');
      await fs.writeFile(typesPath, typesContent.trim());
      await fs.chmod(typesPath, 0o644);

      const tsconfigPath = path.join(
        this._config.projectDirectory,
        'tsconfig.json'
      );
      const tsconfigContent = await fs.readFile(tsconfigPath, 'utf-8');

      const tsconfig = JSON.parse(tsconfigContent);
      const relativeTypesDir = path.relative(
        this._config.projectDirectory,
        this._config.typesDirectory
      );
      const typesIncludePath = `${relativeTypesDir}/**/*.d.ts`;

      if (!tsconfig.include.includes(typesIncludePath)) {
        tsconfig.include.push(typesIncludePath);
        await fs.writeFile(tsconfigPath, JSON.stringify(tsconfig, null, 2));
      }

      spinner.succeed(chalk.green('Types generated successfully.'));
    } catch (error) {
      spinner.fail(chalk.red('Failed to generate types.'));
      logger.error(chalk.red(`Error: ${(error as Error).message}`));
    }
  }

  private async _resolveEntryPoint(entryPoint?: string) {
    const options: string[] = [];

    if (entryPoint) {
      options.push(
        entryPoint,
        `${entryPoint}.ts`,
        `${entryPoint}.js`,
        path.join(this._config.projectDirectory, 'src', entryPoint),
        path.join(this._config.projectDirectory, 'src', `${entryPoint}.ts`),
        path.join(this._config.projectDirectory, 'src', `${entryPoint}.js`)
      );
    } else {
      options.push(
        path.join(this._config.projectDirectory, 'index.ts'),
        path.join(this._config.projectDirectory, 'index.js'),
        path.join(this._config.projectDirectory, 'src', 'index.ts'),
        path.join(this._config.projectDirectory, 'src', 'index.js'),
        path.join(this._config.projectDirectory, 'main.ts'),
        path.join(this._config.projectDirectory, 'main.js'),
        path.join(this._config.projectDirectory, 'src', 'main.ts'),
        path.join(this._config.projectDirectory, 'src', 'main.js')
      );
    }

    for (const option of options) {
      const fullPath = path.join(this._config.projectDirectory, option);
      try {
        const stat = await fs.stat(fullPath);
        if (stat.isFile()) {
          return fullPath;
        }
      } catch {
        // File does not exist, continue to next option
      }
    }

    throw new Error(
      'Could not resolve entry point. Please specify a valid entry point or create an index.ts file in the project root.'
    );
  }

  async build(options?: { minify?: boolean; entryPoint?: string }) {
    const spinner = ora(chalk.blue('Building agent...')).start();
    try {
      const entryPoint = await this._resolveEntryPoint(options?.entryPoint);

      const result = await esbuild.build({
        write: false,
        bundle: true,
        format: 'esm',
        platform: 'neutral',
        target: 'es2022',
        minify: options?.minify === false ? false : true,
        external: ['@calljmp/agent', 'path', 'fs', 'os'],
        entryPoints: [entryPoint],
        absWorkingDir: path.resolve(this._config.projectDirectory),
        tsconfig: path.join(this._config.projectDirectory, 'tsconfig.json'),
      });

      if (result.errors.length > 0) {
        throw new Error(
          `Build failed: ${result.errors.map(e => e.text).join('\n')}`
        );
      }

      const code = result.outputFiles?.[0]?.text;
      if (!code) {
        throw new Error('Build failed: No output generated.');
      }

      spinner.succeed(chalk.green('Agent built.'));
      return { code };
    } catch (e) {
      spinner.fail(chalk.red('Agent build failed.'));
      throw new Error(`Build failed: ${(e as Error).message}`);
    }
  }

  async deploy(
    project: Project,
    options?: {
      entryPoint?: string;
    }
  ) {
    const build = await this.build(options);

    const spinner = ora(chalk.blue('Deploying agent...')).start();
    try {
      const id = await this._deploy({
        projectId: project.id,
        ...build,
      });
      const agent = await this._retrieve({ id, projectId: project.id });
      spinner.succeed(chalk.green('Agent deployed:'));
      logger.info(
        [
          `name: ${agent.name}`,
          `description: ${agent.description}`,
          `id: ${agent.deploymentId}`,
          `version: ${agent.version}`,
        ]
          .map(line => `  - ${line}`)
          .join('\n')
      );
      return { id: agent.deploymentId };
    } catch (error) {
      spinner.fail(
        chalk.red(`Failed to deploy agent: ${(error as Error).message}`)
      );
      throw error;
    }
  }

  async run<Input = unknown>(project: Project, id: string, input?: Input) {
    const spinner = ora(chalk.blue('Running agent...')).start();
    try {
      const result = await this._run<Input>({
        projectId: project.id,
        id,
        input,
      });
      spinner.succeed(chalk.green('Agent run initiated:'));
      logger.info(`  - id: ${result.id}`);
      logger.info(
        `  - url: ${chalk.underline(`https://dash.calljmp.com/project/${project.id}/agents`)}`
      );
      return result;
    } catch (error) {
      spinner.fail(
        chalk.red(`Failed to run agent: ${(error as Error).message}`)
      );
      throw error;
    }
  }

  private async _run<Input = unknown>({
    projectId,
    id,
    input,
  }: {
    projectId: number;
    id: string;
    input?: Input;
  }) {
    const response = await fetch(
      `${this._config.baseUrl}/project/${projectId}/ai/agent/${id}`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${this._config.accessToken}`,
        },
        body: JSON.stringify({ input }),
      }
    );

    if (!response.ok) {
      const { error } = (await response.json()) as {
        error: { name: string; message: string; code: ServiceErrorCode };
      };
      throw ServiceError.fromJson(error);
    }

    const result = (await response.json()) as {
      id: string;
    };

    return result;
  }

  private async _deploy({
    projectId,
    code,
  }: {
    projectId: number;
    code: string;
  }) {
    const response = await fetch(
      `${this._config.baseUrl}/project/${projectId}/ai/agent`,
      {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${this._config.accessToken}`,
        },
        body: JSON.stringify({ code }),
      }
    );

    if (!response.ok) {
      const { error } = (await response.json()) as {
        error: { name: string; message: string; code: ServiceErrorCode };
      };
      throw ServiceError.fromJson(error);
    }

    const { id } = (await response.json()) as { id: string };
    return id;
  }

  private async _retrieve({
    id,
    projectId,
  }: {
    id: string;
    projectId: number;
  }) {
    const response = await fetch(
      `${this._config.baseUrl}/project/${projectId}/ai/agent/${id}`,
      {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${this._config.accessToken}`,
        },
      }
    );

    if (!response.ok) {
      const { error } = (await response.json()) as {
        error: { name: string; message: string; code: ServiceErrorCode };
      };
      throw ServiceError.fromJson(error);
    }

    const json = (await response.json()) as Record<string, unknown>;
    return jsonToAgent(json);
  }
}
