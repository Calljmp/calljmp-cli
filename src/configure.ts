import Handlebars from 'handlebars';
import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { exec } from 'child_process';
import ora from 'ora';
import enquirer from 'enquirer';
import logger from './logger';
import { readVariables } from './env';
import { detectProjectType, ProjectType } from './mobile';

export async function configureIgnores({
  directory,
  entries,
}: {
  directory: string;
  entries: string[];
}) {
  const gitIgnorePath = path.join(directory, '.gitignore');

  // Check if .gitignore exists
  let gitIgnoreContent = '';
  try {
    gitIgnoreContent = await fs.readFile(gitIgnorePath, 'utf-8');
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
      throw error;
    }
    // .gitignore doesn't exist, we'll create a new one
    logger.info(chalk.yellow('Creating new .gitignore'));
  }

  const lines = gitIgnoreContent.split('\n');
  let contentUpdated = false;

  // Check each entry and add if missing
  for (const entry of entries) {
    const hasEntry = lines.some(line => {
      const trimmed = line.trim();
      return (
        trimmed === entry || trimmed === `/${entry}` || trimmed === `${entry}/`
      );
    });

    if (!hasEntry) {
      // Add entry to .gitignore
      if (!gitIgnoreContent.endsWith('\n') && gitIgnoreContent !== '') {
        gitIgnoreContent += '\n';
      }
      gitIgnoreContent += `${entry}\n`;
      logger.info(chalk.yellow(`Adding ${entry} to .gitignore`));
      contentUpdated = true;
    }
  }

  if (contentUpdated) {
    await fs.writeFile(gitIgnorePath, gitIgnoreContent, 'utf-8');
  }
}

Handlebars.registerHelper('camelCase', function (str: string) {
  return str
    .toLowerCase()
    .replace(/[-_]+(.)?/g, (_, char) => (char ? char.toUpperCase() : ''))
    .replace(/^(.)/, char => char.toLowerCase());
});

async function template(name: string, context: Record<string, any> = {}) {
  const source = await fs.readFile(
    path.join(__dirname, '../templates', name),
    'utf-8'
  );
  const template = Handlebars.compile(source);
  const content = template(context);
  return content;
}

export async function configureService({
  directory,
  entry,
  buckets = {},
}: {
  directory: string;
  entry: string;
  buckets?: Record<string, string>;
}) {
  const envs = Object.keys(await readVariables(directory, 'production'));

  const variables = envs.filter(
    key => !key.toUpperCase().startsWith('SECRET_')
  );
  const secrets = envs
    .filter(key => key.toUpperCase().startsWith('SECRET_'))
    .map(key => key.toUpperCase().replace('SECRET_', ''));

  await fs.mkdir(path.dirname(entry), { recursive: true });

  await configureIgnores({
    directory,
    entries: ['.calljmp', '.service.env', '.env'],
  });

  const typesDir = path.join(directory, '.calljmp', 'types');
  await fs.mkdir(typesDir, { recursive: true });

  const typesFile = path.join(typesDir, 'service.d.ts');
  const typesContent = await template('service-types.hbr', {
    variables,
    secrets,
    buckets: Object.entries(buckets).map(([name, binding]) => ({
      name,
      binding,
    })),
  });
  await fs.writeFile(typesFile, typesContent, 'utf-8');

  const cfTypesFile = path.join(typesDir, 'cf.d.ts');
  const cfTypesContent = await template('cf-types.hbr');
  await fs.writeFile(cfTypesFile, cfTypesContent, 'utf-8');

  const indexTypesFile = path.join(typesDir, 'index.d.ts');
  const indexTypesContent = `// Do not edit this file directly. It is generated by the Calljmp CLI.

/* eslint-disable */

export * from './service';
export * from './cf';
`;
  await fs.writeFile(indexTypesFile, indexTypesContent, 'utf-8');

  const exists = await fs
    .access(entry, fs.constants.R_OK)
    .then(() => true)
    .catch(() => false);
  if (!exists) {
    const entryContent = await template('entry.hbr');
    await fs.writeFile(entry, entryContent, 'utf-8');
  }

  await updateTypescriptConfig(directory);
}

async function installNpmPackage(
  directory: string,
  packageName: string,
  options: {
    dev?: boolean;
    promptForPackageManager?: boolean;
    packageManagerMessage?: string;
  } = {}
) {
  const {
    dev = false,
    promptForPackageManager = true,
    packageManagerMessage,
  } = options;

  const packageJsonPath = path.join(directory, 'package.json');
  const packageContent = await fs.readFile(packageJsonPath, 'utf-8');
  const packageJson = JSON.parse(packageContent);

  // Check if already installed
  if (
    (!dev &&
      packageJson.dependencies &&
      packageName in packageJson.dependencies) ||
    (dev &&
      packageJson.devDependencies &&
      packageName in packageJson.devDependencies)
  ) {
    // Silently skip if already installed
    return;
  }

  let packageManager: 'npm' | 'yarn' | 'pnpm' = 'npm';

  if (promptForPackageManager) {
    const hasYarnLock = await fs
      .access(path.join(directory, 'yarn.lock'))
      .then(() => true)
      .catch(() => false);

    const pmResponse = await enquirer.prompt<{
      packageManager: 'npm' | 'yarn' | 'pnpm';
    }>({
      type: 'select',
      name: 'packageManager',
      message: packageManagerMessage || 'Select package manager',
      choices: [
        { name: 'npm', value: 'npm' },
        { name: 'yarn', value: 'yarn' },
        { name: 'pnpm', value: 'pnpm' },
      ],
      initial: hasYarnLock ? 1 : 0,
    });

    packageManager = pmResponse.packageManager;
  }

  const spinner = ora(chalk.dim(`Installing ${packageName}...`)).start();
  try {
    const cmd =
      packageManager === 'yarn'
        ? 'yarn add'
        : packageManager === 'pnpm'
          ? 'pnpm add'
          : 'npm install';

    const flags: string[] = [];
    if (dev) {
      flags.push('--save-dev');
    }

    await new Promise((resolve, reject) => {
      exec(
        `${cmd} ${flags.join(' ')} ${packageName}`,
        { cwd: directory },
        error => {
          if (error) {
            reject(error);
          } else {
            resolve(null);
          }
        }
      );
    });

    spinner.succeed(chalk.dim(`Installed ${packageName}`));
  } catch (error) {
    spinner.fail(chalk.red(`Failed to install ${packageName}`));
    throw error;
  } finally {
    spinner.stop();
  }

  return packageManager;
}

async function configureReactNativeDependencies(directory: string) {
  await installNpmPackage(directory, '@calljmp/react-native');
}

async function configureFlutterDependencies(directory: string) {
  const pubspecPath = path.join(directory, 'pubspec.yaml');

  // Check if pubspec.yaml exists
  const pubspecExists = await fs
    .access(pubspecPath, fs.constants.R_OK)
    .then(() => true)
    .catch(() => false);

  if (!pubspecExists) {
    logger.warn(
      chalk.yellow('No pubspec.yaml found, skipping Flutter dependencies')
    );
    return;
  }

  const installPackage = async (packageName: string) => {
    // Read pubspec.yaml to check if package is already installed
    try {
      const pubspecContent = await fs.readFile(pubspecPath, 'utf-8');
      if (pubspecContent.includes(`${packageName}:`)) {
        // Package already exists, skip
        return;
      }
    } catch {
      // If we can't read pubspec.yaml, proceed with installation
    }

    const spinner = ora(chalk.dim(`Installing ${packageName}...`)).start();
    try {
      await new Promise((resolve, reject) => {
        exec(`flutter pub add ${packageName}`, { cwd: directory }, error => {
          if (error) {
            reject(error);
          } else {
            resolve(null);
          }
        });
      });
      spinner.succeed(chalk.dim(`Installed ${packageName}`));
    } catch (error) {
      spinner.fail(chalk.red(`Failed to install ${packageName}`));
      throw error;
    } finally {
      spinner.stop();
    }
  };

  await installPackage('calljmp');
}

export async function configureDependencies({
  directory,
}: {
  directory: string;
}) {
  const confirmResponse = await enquirer.prompt<{ confirm: boolean }>({
    type: 'confirm',
    name: 'confirm',
    message: 'Install dependencies now?',
    initial: true,
  });

  if (!confirmResponse.confirm) {
    return;
  }

  const projectType = detectProjectType(directory);
  if (projectType === ProjectType.ReactNative) {
    await configureReactNativeDependencies(directory);
  } else if (projectType === ProjectType.Flutter) {
    await configureFlutterDependencies(directory);
  } else {
    logger.warn(chalk.yellow(`Unsupported project type: ${projectType}`));
  }

  await installNpmPackage(directory, '@calljmp/service', {
    packageManagerMessage: 'Select package manager for @calljmp/service',
  });
}

async function updateTypescriptConfig(directory: string) {
  const tsconfigPath = path.join(directory, 'tsconfig.json');
  try {
    const tsconfigContent = await fs.readFile(tsconfigPath, 'utf-8');
    const tsconfig = JSON.parse(tsconfigContent);

    if (!tsconfig.include) {
      tsconfig.include = [];
    }

    if (!tsconfig.include.includes('.calljmp/types/**/*.ts')) {
      tsconfig.include.push('.calljmp/types/**/*.ts');
      await fs.writeFile(
        tsconfigPath,
        JSON.stringify(tsconfig, null, 2),
        'utf-8'
      );
    }
  } catch {
    // noop
  }
}
