import fs from 'fs/promises';
import path from 'path';
import chalk from 'chalk';
import { exec } from 'child_process';
import ora from 'ora';
import enquirer from 'enquirer';
import logger from './logger';
import { readVariables } from './env';

export async function configureIgnores({
  directory,
  entries,
}: {
  directory: string;
  entries: string[];
}) {
  const gitIgnorePath = path.join(directory, '.gitignore');

  // Check if .gitignore exists
  let gitIgnoreContent = '';
  try {
    gitIgnoreContent = await fs.readFile(gitIgnorePath, 'utf-8');
  } catch (error) {
    if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
      throw error;
    }
    // .gitignore doesn't exist, we'll create a new one
    logger.info(chalk.blue('Creating new .gitignore'));
  }

  const lines = gitIgnoreContent.split('\n');
  let contentUpdated = false;

  // Check each entry and add if missing
  for (const entry of entries) {
    const hasEntry = lines.some((line) => {
      const trimmed = line.trim();
      return (
        trimmed === entry || trimmed === `/${entry}` || trimmed === `${entry}/`
      );
    });

    if (!hasEntry) {
      // Add entry to .gitignore
      if (!gitIgnoreContent.endsWith('\n') && gitIgnoreContent !== '') {
        gitIgnoreContent += '\n';
      }
      gitIgnoreContent += `${entry}\n`;
      logger.info(chalk.blue(`Adding ${entry} to .gitignore`));
      contentUpdated = true;
    }
  }

  if (contentUpdated) {
    await fs.writeFile(gitIgnorePath, gitIgnoreContent, 'utf-8');
  }
}

export async function configureService({
  directory,
  service,
  hono,
}: {
  directory: string;
  service: string;
  hono?: boolean;
}) {
  const envs = Object.keys(await readVariables(directory));

  const variables = envs.filter(
    (key) => !key.toUpperCase().startsWith('SECRET_')
  );
  const secrets = envs
    .filter((key) => key.toUpperCase().startsWith('SECRET_'))
    .map((key) => key.toUpperCase().replace('SECRET_', ''));

  const content = `
// Do not edit this file directly. It is generated by the Calljmp CLI.

import { D1Database } from '@cloudflare/workers-types';
${
  hono
    ? `
import { Hono, Context, Next, Schema } from 'hono';
import { BlankSchema } from 'hono/types';
      `.trim()
    : ''
}

export enum Platform {
  Unknown = 'unknown',
  Android = 'android',
  IOS = 'ios',
}

const SERVICE_ARGS_HEADER = 'X-Calljmp-Args';

export class ServiceArgs {
  public readonly trusted: boolean;
  public readonly platform: Platform;
  public readonly serviceId: string;
  public readonly userId?: string;

  private constructor(data: Record<string, unknown>) {
    this.trusted = data.trusted === true;
    this.platform = data.platform as Platform || Platform.Unknown;
    this.serviceId = data.serviceId as string;

    if (this.trusted) {
      this.userId = data.userId as string;
    }
  }

  static from(args: any) {
    let value: string | null = null;

    if ('req' in args && 'header' in args.req && typeof args.req.header === 'function') {
      // Hono Context
      value = args.req.header(SERVICE_ARGS_HEADER);
    } else if ('header' in args && typeof args.header === 'function') {
      // Hono Request
      value = args.header(SERVICE_ARGS_HEADER);
    } else if (args instanceof Request) {
      value = args.headers.get(SERVICE_ARGS_HEADER);
    } else if (args && typeof args === 'object') {
      value = args[SERVICE_ARGS_HEADER];
    } else if (typeof args === 'string') {
      value = args;
    }

    if (!value) {
      throw new Error(\`Unable to resolve arguments from \${ args }\`);
    }

    const json = JSON.parse(value);

    return new ServiceArgs(json);
  }

  static tryFrom(args: any) {
    try {
      const data = ServiceArgs.from(args);
      return {
        args: data,
        error: null,
      }
    } catch (error) {
      return {
        args: null,
        error: error as Error,
      }
    }
  }
}

export interface Env {
  db: D1Database;

  // Variables
  ${variables.map((variable) => `${variable}: string;`).join('\n  ')}

  // Secrets
  ${secrets.map((secret) => `${secret}: string;`).join('\n  ')}
}

export interface ServiceEnv {
  Bindings: Env;
  Variables: {
    ${
      hono
        ? `
    trusted: boolean;
    platform: Platform;
    serviceId: string;
    userId?: string;
      `.trim()
        : ''
    }
  };
}

${
  hono
    ? `
export const Service = <S extends Schema = BlankSchema, BasePath extends string = "/">() => new Hono<ServiceEnv, S, BasePath>()
  .use(async (c: Context, next: Next) => {
    c.set('trusted', false);
    c.set('platform', Platform.Unknown);

    const { args } = ServiceArgs.tryFrom(c);
    if (args) {
      for (const [key, value] of Object.entries(args)) {
        c.set(key, value);
      }
    }

    await next();
    return;
  });
      `.trim()
    : ''
}
  `.trim();

  await fs.writeFile(service, content, 'utf-8');
  logger.info(chalk.blue(`Generating ${path.basename(service)}`));
}

export async function configureDependencies({
  directory,
}: {
  directory: string;
}) {
  const currentDirectory = process.cwd();
  const relativePath = path.relative(currentDirectory, directory);

  const { confirmedDirectory } = await enquirer.prompt<{
    confirmedDirectory: string;
  }>({
    type: 'input',
    name: 'confirmedDirectory',
    message: 'Confirm the project directory',
    initial: relativePath,
  });

  const projectDirectory = path.resolve(currentDirectory, confirmedDirectory);

  const hasYarnLock = await fs
    .access(path.join(projectDirectory, 'yarn.lock'))
    .then(() => true)
    .catch(() => false);

  const { packageManager } = await enquirer.prompt<{
    packageManager: 'npm' | 'yarn' | 'pnpm';
  }>({
    type: 'select',
    name: 'packageManager',
    message: 'Select package manager',
    choices: [
      { name: 'npm', value: 'npm' },
      { name: 'yarn', value: 'yarn' },
      { name: 'pnpm', value: 'pnpm' },
    ],
    initial: hasYarnLock ? 1 : 0,
  });

  const packageJsonPath = path.join(projectDirectory, 'package.json');
  const packageContent = await fs.readFile(packageJsonPath, 'utf-8');
  const packageJson = JSON.parse(packageContent);

  const install = async (packageName: string, dev?: boolean) => {
    const spinner = ora(`Installing ${packageName}...`).start();
    try {
      if (
        !dev &&
        packageJson.dependencies &&
        packageName in packageJson.dependencies
      ) {
        spinner.info(chalk.yellow(`Already installed ${packageName}`));
        return;
      }
      if (
        dev &&
        packageJson.devDependencies &&
        packageName in packageJson.devDependencies
      ) {
        spinner.info(chalk.yellow(`Already installed ${packageName}`));
        return;
      }

      const cmd =
        packageManager === 'yarn'
          ? 'yarn add'
          : packageManager === 'pnpm'
          ? 'pnpm add'
          : 'npm install';
      const devFlag = dev ? '--save-dev' : '--save';

      await new Promise((resolve, reject) => {
        exec(
          `${cmd} ${devFlag} ${packageName}`,
          { cwd: projectDirectory },
          (error) => {
            if (error) {
              reject(error);
            } else {
              resolve(null);
            }
          }
        );
      });

      spinner.succeed(chalk.green(`Installed ${packageName}`));
    } catch (error) {
      spinner.fail(chalk.red(`Failed to install ${packageName}`));
      throw error;
    } finally {
      spinner.stop();
    }
  };

  await install('@cloudflare/workers-types', true);
  await install('@calljmp/react-native');
}
